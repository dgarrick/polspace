<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Polspace - 3D Political Compass</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 40px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
                border-radius: 15px;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 15px;
                border-radius: 10px;
            }
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 2em;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.6em;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.4em;
            }
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            margin-bottom: 30px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        .question-container {
            margin-bottom: 40px;
        }

        .question-text {
            font-size: 1.2em;
            color: #333;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .option {
            padding: 15px 20px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
        }

        .option:hover {
            border-color: #667eea;
            background: #f8f9ff;
            transform: translateX(5px);
        }

        .option.selected {
            border-color: #667eea;
            background: #667eea;
            color: white;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 30px;
        }

        button {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        @media (max-width: 768px) {
            button {
                padding: 14px 32px;
                font-size: 1.05em;
            }
        }

        @media (max-width: 480px) {
            button {
                padding: 15px 35px;
                font-size: 1.1em;
            }
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #e0e0e0;
            color: #666;
        }

        .btn-secondary:hover {
            background: #d0d0d0;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .result-container {
            text-align: center;
        }

        #canvas-container {
            width: 100%;
            height: 600px;
            margin: 30px auto;
            border: 2px solid #333;
            border-radius: 10px;
            overflow: hidden;
            background: #1a1a2e;
            touch-action: none; /* Prevent default touch behaviors */
        }

        @media (max-width: 768px) {
            #canvas-container {
                height: 400px;
                margin: 20px auto;
            }
        }

        @media (max-width: 480px) {
            #canvas-container {
                height: 350px;
                margin: 15px auto;
                border-radius: 5px;
            }
        }

        .result-text {
            font-size: 1.5em;
            margin: 20px 0;
            color: #333;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        @media (max-width: 768px) {
            .result-text {
                font-size: 1.3em;
            }
        }

        @media (max-width: 480px) {
            .result-text {
                font-size: 1.2em;
                gap: 10px;
            }
        }

        .ideology-flag {
            width: 48px;
            height: 32px;
            border: 2px solid #333;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .flag-copy-hint {
            font-size: 0.7em;
            color: #999;
            font-weight: normal;
            font-style: italic;
        }

        .ideology-description {
            font-size: 1.1em;
            color: #666;
            margin: 20px 0;
            line-height: 1.6;
        }

        @media (max-width: 768px) {
            .ideology-description {
                font-size: 1em;
            }
        }

        @media (max-width: 480px) {
            .ideology-description {
                font-size: 0.95em;
            }
        }

        .score-details {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin: 30px 0;
            text-align: left;
        }

        @media (max-width: 768px) {
            .score-details {
                grid-template-columns: 1fr;
                gap: 15px;
                margin: 20px 0;
            }
        }

        .score-card {
            padding: 20px;
            background: #f8f9ff;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }

        .score-card h3 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1em;
        }

        .score-card p {
            font-size: 0.9em;
            color: #666;
        }

        .controls {
            text-align: center;
            color: #666;
            margin-top: 20px;
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            .controls {
                font-size: 0.85em;
            }
        }

        @media (max-width: 480px) {
            .controls {
                font-size: 0.8em;
            }
        }

        .ideology-nav {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }

        @media (max-width: 768px) {
            .ideology-nav {
                gap: 15px;
                flex-wrap: wrap;
            }
        }

        @media (max-width: 480px) {
            .ideology-nav {
                gap: 10px;
            }
        }

        .ideology-nav button {
            padding: 10px 20px;
            font-size: 1.2em;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        @media (max-width: 768px) {
            .ideology-nav button {
                padding: 12px 24px;
                font-size: 1.3em;
            }
        }

        @media (max-width: 480px) {
            .ideology-nav button {
                padding: 15px 25px;
                font-size: 1.5em;
            }
        }

        .ideology-nav button:hover:not(:disabled) {
            background: #5568d3;
            transform: scale(1.1);
        }

        .ideology-nav button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .ideology-nav-label {
            font-size: 1.1em;
            color: #333;
            font-weight: 600;
            min-width: 200px;
        }

        @media (max-width: 768px) {
            .ideology-nav-label {
                font-size: 1em;
                min-width: 150px;
            }
        }

        @media (max-width: 480px) {
            .ideology-nav-label {
                font-size: 0.9em;
                min-width: 100%;
                text-align: center;
            }
        }

        .hidden {
            display: none;
        }

        .legend {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 20px 0;
            font-size: 0.9em;
        }

        @media (max-width: 480px) {
            .legend {
                grid-template-columns: 1fr;
                font-size: 0.85em;
            }
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid #333;
        }

        @media (max-width: 768px) {
            .score-details {
                grid-template-columns: 1fr;
            }

            #canvas-container {
                height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="intro-section">
            <h1>Polspace</h1>
            <p class="subtitle">A 3D Political Compass</p>
            
            <div style="margin: 40px 0; text-align: left;">
                <p style="font-size: 1.1em; line-height: 1.8; color: #333; margin-bottom: 20px;">
                    Welcome to <strong>Polspace</strong> — a new way to visualize political ideology in three dimensions.
                </p>
                
                <p style="font-size: 1em; line-height: 1.8; color: #666; margin-bottom: 20px;">
                    Unlike traditional left-right political compasses, Polspace maps your views across three axes:
                </p>
                
                <ul style="font-size: 1em; line-height: 2; color: #666; margin-left: 30px; margin-bottom: 30px;">
                    <li><strong>Accelerationism ↔ Decelerationism:</strong> Do you embrace rapid technological progress or prioritize ecological limits and caution?</li>
                    <li><strong>Centralization ↔ Decentralization:</strong> Do you favor concentrated power structures or distributed, local autonomy?</li>
                    <li><strong>Individualism ↔ Collectivism:</strong> Do you prioritize personal freedom or community wellbeing?</li>
                </ul>
                
                <p style="font-size: 1em; line-height: 1.8; color: #666; margin-bottom: 40px;">
                    Answer 21 questions to discover which political ideology you're closest to in 3D space, 
                    from Crypto-Anarchism to Georgism, Eco-Fascism to Solarpunk.
                </p>
            </div>

            <div style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap;">
                <button class="btn-primary" onclick="startTest()" style="font-size: 1.1em; padding: 15px 40px;">
                    Start the Test
                </button>
                <button class="btn-secondary" onclick="skipToCube()" style="font-size: 1.1em; padding: 15px 40px;">
                    Skip to Polspace
                </button>
            </div>
        </div>

        <div id="quiz-section" class="hidden">
            <h1>Polspace</h1>
            <p class="subtitle">Discover which political ideology you're closest to</p>
            
            <div class="progress-bar">
                <div class="progress-fill" id="progress"></div>
            </div>

            <div class="question-container">
                <div class="question-text" id="question-text"></div>
                <div class="options" id="options"></div>
            </div>

            <div class="navigation">
                <button class="btn-secondary" id="prev-btn" onclick="previousQuestion()">Previous</button>
            </div>
        </div>

        <div id="result-section" class="hidden">
            <h1>Your Ideology Match</h1>
            
            <div class="result-text" id="result-ideology"></div>
            <div style="text-align: center; font-size: 0.8em; color: #999; margin: -10px 0 10px 0;">
                <span class="flag-copy-hint">Right-click flag to save • Top: Economic • Middle: Governance • Bottom: Social</span>
            </div>
            <div class="ideology-description" id="ideology-description"></div>

            <div id="canvas-container"></div>
            
            <div class="ideology-nav">
                <button onclick="previousIdeology()">← Previous</button>
                <span class="ideology-nav-label" id="focused-ideology">Your Position</span>
                <button onclick="nextIdeology()">Next →</button>
            </div>
            
            <div class="controls">
                Drag to rotate • Scroll to zoom • Your position is the glowing point
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #0ff;"></div>
                    <span>Accelerationism (top)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #0f0;"></div>
                    <span>Decelerationism (bottom)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #00f;"></div>
                    <span>Centralization (right)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f00;"></div>
                    <span>Decentralization (left)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff0;"></div>
                    <span>Individualism (front)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f0f;"></div>
                    <span>Collectivism (back)</span>
                </div>
            </div>

            <div class="score-details">
                <div class="score-card">
                    <h3>Economic Philosophy</h3>
                    <p id="economic-result"></p>
                </div>
                <div class="score-card">
                    <h3>Governance Model</h3>
                    <p id="governance-result"></p>
                </div>
                <div class="score-card">
                    <h3>Social Organization</h3>
                    <p id="social-result"></p>
                </div>
            </div>

            <button class="btn-primary" onclick="restartQuiz()" style="margin-top: 20px;">Take Test Again</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="questions.js"></script>
    <script src="ideologies.js"></script>
    <script src="antipodes.js"></script>
    <script>
        let currentQuestion = 0;
        let answers = [];
        let scene, camera, renderer, userPoint, ideologyPoints = [];
        let currentFocusIndex = -1; // -1 means focused on user, 0+ means focused on ideology
        let userCoords = null;
        let skipMode = false;
        let userResultDescription = ""; // Store user's result description
        let currentGlow = null; // Track the current glow effect
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        // Function to get current look-at point dynamically
        function getCurrentLookAt() {
            if (currentFocusIndex === -1) {
                return userCoords || { x: 0, y: 0, z: 0 };
            } else if (currentFocusIndex >= 0 && currentFocusIndex < ideologies.length) {
                return ideologies[currentFocusIndex].coords;
            }
            return { x: 0, y: 0, z: 0 };
        }

        function onOrbClick(event) {
            // Calculate mouse position in normalized device coordinates
            const canvas = renderer.domElement;
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObjects(ideologyPoints);

            if (intersects.length > 0) {
                // Find which ideology was clicked
                const clickedPoint = intersects[0].object;
                const clickedIndex = ideologyPoints.indexOf(clickedPoint);
                
                if (clickedIndex !== -1) {
                    // Update focus to the clicked ideology
                    currentFocusIndex = clickedIndex;
                    focusOnPoint();
                }
            } else if (userPoint) {
                // Check if user point was clicked
                const userIntersects = raycaster.intersectObject(userPoint);
                if (userIntersects.length > 0) {
                    currentFocusIndex = -1;
                    focusOnPoint();
                }
            }
        }

        function previousIdeology() {
            if (currentFocusIndex > -1) {
                currentFocusIndex--;
                focusOnPoint();
            }
        }

        function nextIdeology() {
            if (currentFocusIndex < ideologies.length - 1) {
                currentFocusIndex++;
                focusOnPoint();
            }
        }

        // Navigate to an ideology programmatically by index (used by antipode link)
        function navigateToIdeology(index) {
            if (typeof index !== 'number' || index < 0 || index >= ideologies.length) return;
            currentFocusIndex = index;
            focusOnPoint();
        }

        function addGlowToPoint(point) {
            // Remove existing glow if any
            if (currentGlow) {
                currentGlow.parent.remove(currentGlow);
                currentGlow = null;
            }

            // Add new glow effect with neutral white color
            const glowGeometry = new THREE.SphereGeometry(0.12, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff, // White
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            point.add(glow);
            currentGlow = glow;

            // Enable rotation for this point
            point.userData.shouldRotate = true;
        }

        function focusOnPoint() {
            let targetCoords;
            let label;
            let description;
            let targetPoint;

            // Disable rotation for all points first
            if (userPoint) userPoint.userData.shouldRotate = false;
            ideologyPoints.forEach(point => point.userData.shouldRotate = false);

            if (currentFocusIndex === -1) {
                // Focus on user
                targetCoords = userCoords;
                targetPoint = userPoint;
                label = "Your Position";
                description = userResultDescription; // Use stored description
                
                // Show user's flag
                const { economicScore, governanceScore, socialScore } = calculateResults();
                const flagSvg = createTricolorFlag(economicScore, governanceScore, socialScore);
                document.getElementById('result-ideology').innerHTML = flagSvg + label;
            } else {
                // Focus on ideology
                const ideology = ideologies[currentFocusIndex];
                targetCoords = ideology.coords;
                targetPoint = ideologyPoints[currentFocusIndex];
                label = ideology.name;
                description = ideology.description;
                
                // Create flag for this ideology based on its coordinates
                const flagSvg = createTricolorFlag(targetCoords.y, targetCoords.x, targetCoords.z);
                document.getElementById('result-ideology').innerHTML = flagSvg + label;
            }

            document.getElementById('focused-ideology').textContent = label;
            
            // Build HTML description so the antipode name can be a clickable link
            let fullDescriptionHtml = `<p>${description}</p>`;

            if (currentFocusIndex !== -1 && typeof antipodes !== 'undefined') {
                const currentIdeology = ideologies[currentFocusIndex];
                if (currentIdeology) {
                    const antipodeName = antipodes[currentIdeology.name];
                    if (antipodeName) {
                        const antipodeIndex = ideologies.findIndex(i => i.name === antipodeName);
                        if (antipodeIndex !== -1) {
                            fullDescriptionHtml += `<p><strong>Antipode:</strong> <a href="#" onclick="navigateToIdeology(${antipodeIndex}); return false;" style="color:#667eea; text-decoration:underline;">${antipodeName}</a></p>`;
                        } else {
                            // Fallback: show antipode name but not clickable
                            fullDescriptionHtml += `<p><strong>Antipode:</strong> ${antipodeName}</p>`;
                        }
                    }
                }
            }

            document.getElementById('ideology-description').innerHTML = fullDescriptionHtml;

            // Add glow effect to focused point
            if (targetPoint) {
                addGlowToPoint(targetPoint);
            }

            // Animate camera to new position
            animateCameraToPoint(targetCoords);
        }

        function animateCameraToPoint(targetCoords) {
            const defaultDistance = 2.0; // Reduced from 2.5 to stay closer
            
            const startPos = {
                x: camera.position.x,
                y: camera.position.y,
                z: camera.position.z
            };
            
            // Calculate direction from current position to maintain viewing angle
            const currentLookAt = getCurrentLookAt();
            const direction = new THREE.Vector3(
                startPos.x - currentLookAt.x,
                startPos.y - currentLookAt.y,
                startPos.z - currentLookAt.z
            ).normalize();
            
            // End position at default distance from new target
            const endPos = {
                x: targetCoords.x + direction.x * defaultDistance,
                y: targetCoords.y + direction.y * defaultDistance,
                z: targetCoords.z + direction.z * defaultDistance
            };

            const duration = 800; // ms
            const startTime = Date.now();

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Ease in-out
                const eased = progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                camera.position.set(
                    startPos.x + (endPos.x - startPos.x) * eased,
                    startPos.y + (endPos.y - startPos.y) * eased,
                    startPos.z + (endPos.z - startPos.z) * eased
                );
                camera.lookAt(targetCoords.x, targetCoords.y, targetCoords.z);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }

            animate();
        }

        function startTest() {
            document.getElementById('intro-section').classList.add('hidden');
            document.getElementById('quiz-section').classList.remove('hidden');
            displayQuestion();
        }

        function skipToCube() {
            // Show cube without user's position (just view all ideologies)
            skipMode = true;
            currentFocusIndex = 0;
            
            document.getElementById('intro-section').classList.add('hidden');
            document.getElementById('result-section').classList.remove('hidden');
            
            document.getElementById('result-ideology').textContent = "Exploring Polspace";
            document.getElementById('ideology-description').textContent = "Use the arrow buttons to navigate between ideologies, or drag to rotate the cube and explore all 24 political ideologies mapped in 3D space.";
            
            // Hide score details when just browsing
            document.querySelector('.score-details').style.display = 'none';
            
            // Initialize 3D scene at center (no user point)
            init3DScene({ x: 0, y: 0, z: 0 }, true);
            
            // Focus on first ideology
            setTimeout(() => {
                focusOnPoint();
            }, 100);
        }

        function displayQuestion() {
            const question = questions[currentQuestion];
            document.getElementById('question-text').textContent = `${currentQuestion + 1}. ${question.text}`;
            
            const optionsContainer = document.getElementById('options');
            optionsContainer.innerHTML = '';
            
            question.options.forEach((option, index) => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'option';
                optionDiv.textContent = option.text;
                optionDiv.onclick = () => selectOption(index);
                
                if (answers[currentQuestion] === index) {
                    optionDiv.classList.add('selected');
                }
                
                optionsContainer.appendChild(optionDiv);
            });

            updateProgress();
            updateButtons();
        }

        function selectOption(index) {
            answers[currentQuestion] = index;
            
            const options = document.querySelectorAll('.option');
            options.forEach((opt, i) => {
                if (i === index) {
                    opt.classList.add('selected');
                } else {
                    opt.classList.remove('selected');
                }
            });
            
            // Auto-advance after a short delay
            setTimeout(() => {
                if (currentQuestion < questions.length - 1) {
                    currentQuestion++;
                    displayQuestion();
                } else {
                    showResults();
                }
            }, 300);
        }

        function previousQuestion() {
            if (currentQuestion > 0) {
                currentQuestion--;
                displayQuestion();
            }
        }

        function updateProgress() {
            const progress = ((currentQuestion + 1) / questions.length) * 100;
            document.getElementById('progress').style.width = progress + '%';
        }

        function updateButtons() {
            document.getElementById('prev-btn').disabled = currentQuestion === 0;
        }

        function calculateResults() {
            let economicScore = 0;
            let governanceScore = 0;
            let socialScore = 0;
            let economicCount = 0;
            let governanceCount = 0;
            let socialCount = 0;

            questions.forEach((question, index) => {
                const answerIndex = answers[index];
                const value = question.options[answerIndex].value;
                
                if (question.axis === 'economic') {
                    economicScore += value;
                    economicCount++;
                } else if (question.axis === 'governance') {
                    governanceScore += value;
                    governanceCount++;
                } else {
                    socialScore += value;
                    socialCount++;
                }
            });

            // Normalize to -1 to 1 range
            economicScore = economicScore / (economicCount * 2);
            governanceScore = governanceScore / (governanceCount * 2);
            socialScore = socialScore / (socialCount * 2);

            return { economicScore, governanceScore, socialScore };
        }

        function findClosestIdeology(userCoords) {
            let minDistance = Infinity;
            let closestIdeology = ideologies[0];

            ideologies.forEach(ideology => {
                const distance = Math.sqrt(
                    Math.pow(userCoords.x - ideology.coords.x, 2) +
                    Math.pow(userCoords.y - ideology.coords.y, 2) +
                    Math.pow(userCoords.z - ideology.coords.z, 2)
                );

                if (distance < minDistance) {
                    minDistance = distance;
                    closestIdeology = ideology;
                }
            });

            return closestIdeology;
        }

        function calculateOrbColor(coords) {
            // Map coordinates from -1 to 1 to 0 to 1 for color mixing
            const xNorm = (coords.x + 1) / 2; // 0 = red (decentral), 1 = blue (national)
            const yNorm = (coords.y + 1) / 2; // 0 = green (decelerationism), 1 = cyan (accelerationism)
            const zNorm = (coords.z + 1) / 2; // 0 = magenta (collect), 1 = yellow (individ)

            // Use additive color mixing
            let r = 0, g = 0, b = 0;

            // X axis: Decentralization (red) vs Nationalism (blue)
            if (xNorm < 0.5) {
                // More decentralized = more red
                r += (1 - xNorm * 2) * 255;
            } else {
                // More nationalist = more blue
                b += ((xNorm - 0.5) * 2) * 255;
            }

            // Y axis: Decelerationism (green) vs Accelerationism (cyan/absence)
            if (yNorm < 0.5) {
                // More techno-pessimist = more green
                g += (1 - yNorm * 2) * 255;
            }
            // Accelerationism contributes cyan tones

            // Z axis: Collectivism (magenta) vs Individualism (yellow)
            if (zNorm < 0.5) {
                // More collectivist = magenta (red + blue)
                const magentaStrength = (1 - zNorm * 2);
                r += magentaStrength * 128;
                b += magentaStrength * 128;
            } else {
                // More individualist = yellow (red + green)
                const yellowStrength = (zNorm - 0.5) * 2;
                r += yellowStrength * 128;
                g += yellowStrength * 128;
            }

            // Clamp values
            r = Math.round(Math.min(255, Math.max(30, r))); // Min 30 to avoid pure black
            g = Math.round(Math.min(255, Math.max(30, g)));
            b = Math.round(Math.min(255, Math.max(30, b)));

            // Convert to hex
            const toHex = (n) => {
                const hex = n.toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            };

            return parseInt(toHex(r) + toHex(g) + toHex(b), 16);
        }

        function getAxisColors(coords) {
            // Get individual color for each axis
            const xNorm = (coords.x + 1) / 2;
            const yNorm = (coords.y + 1) / 2;
            const zNorm = (coords.z + 1) / 2;

            // Return full saturation colors with opacity information
            const minOpacity = 0.4; // Minimum opacity to keep colors visible

            // X axis color
            let xColor, xOpacity;
            if (xNorm < 0.5) {
                xColor = new THREE.Color(1, 0, 0); // Full red (decentralization)
                xOpacity = Math.max(minOpacity, (1 - xNorm * 2));
            } else {
                xColor = new THREE.Color(0, 0, 1); // Full blue (centralization)
                xOpacity = Math.max(minOpacity, (xNorm - 0.5) * 2);
            }

            // Y axis color
            let yColor, yOpacity;
            if (yNorm < 0.5) {
                yColor = new THREE.Color(0, 1, 0); // Full green (decelerationism)
                yOpacity = Math.max(minOpacity, (1 - yNorm * 2));
            } else {
                yColor = new THREE.Color(0, 1, 1); // Full cyan (accelerationism)
                yOpacity = Math.max(minOpacity, (yNorm - 0.5) * 2);
            }

            // Z axis color
            let zColor, zOpacity;
            if (zNorm < 0.5) {
                zColor = new THREE.Color(1, 0, 1); // Full magenta (collectivism)
                zOpacity = Math.max(minOpacity, (1 - zNorm * 2));
            } else {
                zColor = new THREE.Color(1, 1, 0); // Full yellow (individualism)
                zOpacity = Math.max(minOpacity, (zNorm - 0.5) * 2);
            }

            return [
                { color: xColor, opacity: xOpacity },
                { color: yColor, opacity: yOpacity },
                { color: zColor, opacity: zOpacity }
            ];
        }

        function createStripedTexture(axisColorData) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Fill with white background first
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Create three vertical stripes with opacity
            const stripeWidth = canvas.width / 3;

            axisColorData.forEach((data, i) => {
                const color = data.color;
                const opacity = data.opacity;
                
                ctx.globalAlpha = opacity;
                ctx.fillStyle = `rgb(${Math.floor(color.r * 255)}, ${Math.floor(color.g * 255)}, ${Math.floor(color.b * 255)})`;
                ctx.fillRect(i * stripeWidth, 0, stripeWidth, canvas.height);
            });

            ctx.globalAlpha = 1.0; // Reset

            return new THREE.CanvasTexture(canvas);
        }

        function init3DScene(coords, isSkipMode = false) {
            skipMode = isSkipMode;
            if (!skipMode) {
                userCoords = coords;
                currentFocusIndex = -1; // Start focused on user
            }
            const container = document.getElementById('canvas-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            // Camera - position relative to user's orb (or center if skipping)
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            // Position camera at a distance from the user's point
            const cameraDistance = 2.5;
            const lookAtPoint = skipMode ? { x: 0, y: 0, z: 0 } : coords;
            camera.position.set(
                lookAtPoint.x + cameraDistance,
                lookAtPoint.y + cameraDistance,
                lookAtPoint.z + cameraDistance
            );
            camera.lookAt(lookAtPoint.x, lookAtPoint.y, lookAtPoint.z);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);

            // Create cube wireframe - normalized to -1 to +1 range
            const cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
            const edges = new THREE.EdgesGeometry(cubeGeometry);
            const cubeMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
            const cube = new THREE.LineSegments(edges, cubeMaterial);
            scene.add(cube);

            // Add axes with gradients
            const axisLength = 1.2;
            
            // X axis gradient (red to blue: decentralization to centralization)
            const xPoints = [];
            const xColors = [];
            const xSegments = 50;
            for (let i = 0; i <= xSegments; i++) {
                const t = i / xSegments;
                const x = -axisLength + (t * axisLength * 2);
                xPoints.push(new THREE.Vector3(x, 0, 0));
                // Gradient from red to blue
                const r = (1 - t);
                const b = t;
                xColors.push(r, 0, b);
            }
            const xGeometry = new THREE.BufferGeometry().setFromPoints(xPoints);
            xGeometry.setAttribute('color', new THREE.Float32BufferAttribute(xColors, 3));
            const xMaterial = new THREE.LineBasicMaterial({ 
                vertexColors: true,
                linewidth: 3
            });
            const xAxis = new THREE.Line(xGeometry, xMaterial);
            scene.add(xAxis);

            // Y axis gradient (green to cyan: decelerationism to accelerationism)
            const yPoints = [];
            const yColors = [];
            const ySegments = 50;
            for (let i = 0; i <= ySegments; i++) {
                const t = i / ySegments;
                const y = -axisLength + (t * axisLength * 2);
                yPoints.push(new THREE.Vector3(0, y, 0));
                // Gradient from green to cyan
                const g = 1;
                const b = t;
                yColors.push(0, g, b);
            }
            const yGeometry = new THREE.BufferGeometry().setFromPoints(yPoints);
            yGeometry.setAttribute('color', new THREE.Float32BufferAttribute(yColors, 3));
            const yMaterial = new THREE.LineBasicMaterial({ 
                vertexColors: true,
                linewidth: 3
            });
            const yAxis = new THREE.Line(yGeometry, yMaterial);
            scene.add(yAxis);

            // Z axis gradient (magenta to yellow: collectivism to individualism)
            const zPoints = [];
            const zColors = [];
            const zSegments = 50;
            for (let i = 0; i <= zSegments; i++) {
                const t = i / zSegments;
                const z = -axisLength + (t * axisLength * 2);
                zPoints.push(new THREE.Vector3(0, 0, z));
                // Gradient from magenta to yellow
                const r = 1;
                const g = t;
                const b = (1 - t);
                zColors.push(r, g, b);
            }
            const zGeometry = new THREE.BufferGeometry().setFromPoints(zPoints);
            zGeometry.setAttribute('color', new THREE.Float32BufferAttribute(zColors, 3));
            const zMaterial = new THREE.LineBasicMaterial({ 
                vertexColors: true,
                linewidth: 3
            });
            const zAxis = new THREE.Line(zGeometry, zMaterial);
            scene.add(zAxis);

            // Add user point (glowing with color based on position) - only if not skipping
            if (!skipMode) {
                ideologies.push({
                    name: "Your Ideology",
                    coords: coords,
                    description: "Your political ideology. Relevant figures: You.",
                    shortLabel: "You"
                });
            }

            // Add ideology points
            ideologies.forEach(ideology => {
                const axisColors = getAxisColors(ideology.coords);
                const stripedTexture = createStripedTexture(axisColors);
                
                const pointGeometry = new THREE.SphereGeometry(0.05, 32, 32);
                const pointMaterial = new THREE.MeshBasicMaterial({ 
                    map: stripedTexture
                });
                const point = new THREE.Mesh(pointGeometry, pointMaterial);
                point.position.set(
                    ideology.coords.x,
                    ideology.coords.y,
                    ideology.coords.z
                );
                point.userData.shouldRotate = false; // Don't rotate by default
                scene.add(point);
                ideologyPoints.push(point);

                // Add label
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 128;
                context.fillStyle = 'white';
                context.font = 'Bold 24px Arial';
                context.textAlign = 'center';
                const lines = ideology.shortLabel.split('\n');
                lines.forEach((line, i) => {
                    context.fillText(line, 128, 50 + i * 30);
                });

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.set(
                    ideology.coords.x * 1.3,
                    ideology.coords.y * 1.3,
                    ideology.coords.z * 1.3
                );
                sprite.scale.set(0.5, 0.25, 1);
                scene.add(sprite);
            });

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 0.8);
            pointLight.position.set(5, 5, 5);
            scene.add(pointLight);

            // Mouse controls
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };

            // Touch controls for mobile
            let touchStartDistance = 0;
            let touchStartZoom = 1;

            // Add click listener for orb selection
            renderer.domElement.addEventListener('click', onOrbClick, false);

            // Add hover cursor change
            renderer.domElement.addEventListener('mousemove', (event) => {
                if (isDragging) return;
                
                const canvas = renderer.domElement;
                const rect = canvas.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(ideologyPoints);
                const userIntersects = userPoint ? raycaster.intersectObject(userPoint) : [];

                if (intersects.length > 0 || userIntersects.length > 0) {
                    renderer.domElement.style.cursor = 'pointer';
                } else {
                    renderer.domElement.style.cursor = 'grab';
                }
            });

            // Touch event handlers
            renderer.domElement.addEventListener('touchstart', (e) => {
                e.preventDefault();
                
                if (e.touches.length === 1) {
                    // Single touch - rotation
                    isDragging = true;
                    previousMousePosition = {
                        x: e.touches[0].clientX,
                        y: e.touches[0].clientY
                    };
                } else if (e.touches.length === 2) {
                    // Two finger pinch - zoom
                    isDragging = false;
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    touchStartDistance = Math.sqrt(dx * dx + dy * dy);
                    
                    const lookAtPoint = getCurrentLookAt();
                    const distance = Math.sqrt(
                        Math.pow(camera.position.x - lookAtPoint.x, 2) +
                        Math.pow(camera.position.y - lookAtPoint.y, 2) +
                        Math.pow(camera.position.z - lookAtPoint.z, 2)
                    );
                    touchStartZoom = distance;
                }
            }, { passive: false });

            renderer.domElement.addEventListener('touchmove', (e) => {
                e.preventDefault();
                
                if (e.touches.length === 1 && isDragging) {
                    // Single touch rotation
                    const deltaX = e.touches[0].clientX - previousMousePosition.x;
                    const deltaY = e.touches[0].clientY - previousMousePosition.y;

                    const lookAtPoint = getCurrentLookAt();

                    // Calculate rotation - increased speed for mobile
                    const rotationSpeed = 0.008; // Increased from 0.005 for better mobile response
                    const deltaAzimuth = -deltaX * rotationSpeed;
                    const deltaPolar = -deltaY * rotationSpeed;

                    // Current spherical coordinates
                    const radius = Math.sqrt(
                        Math.pow(camera.position.x - lookAtPoint.x, 2) +
                        Math.pow(camera.position.y - lookAtPoint.y, 2) +
                        Math.pow(camera.position.z - lookAtPoint.z, 2)
                    );

                    let theta = Math.atan2(
                        camera.position.x - lookAtPoint.x,
                        camera.position.z - lookAtPoint.z
                    );
                    let phi = Math.acos(
                        (camera.position.y - lookAtPoint.y) / radius
                    );

                    theta += deltaAzimuth;
                    phi += deltaPolar;
                    phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));

                    camera.position.x = lookAtPoint.x + radius * Math.sin(phi) * Math.sin(theta);
                    camera.position.y = lookAtPoint.y + radius * Math.cos(phi);
                    camera.position.z = lookAtPoint.z + radius * Math.sin(phi) * Math.cos(theta);
                    
                    camera.lookAt(lookAtPoint.x, lookAtPoint.y, lookAtPoint.z);

                    previousMousePosition = {
                        x: e.touches[0].clientX,
                        y: e.touches[0].clientY
                    };
                } else if (e.touches.length === 2) {
                    // Pinch zoom
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    const scale = distance / touchStartDistance;
                    const newZoom = touchStartZoom / scale;
                    
                    // Clamp zoom
                    const clampedZoom = Math.max(1.5, Math.min(5, newZoom));
                    
                    const lookAtPoint = getCurrentLookAt();
                    const direction = new THREE.Vector3(
                        camera.position.x - lookAtPoint.x,
                        camera.position.y - lookAtPoint.y,
                        camera.position.z - lookAtPoint.z
                    ).normalize();
                    
                    camera.position.set(
                        lookAtPoint.x + direction.x * clampedZoom,
                        lookAtPoint.y + direction.y * clampedZoom,
                        lookAtPoint.z + direction.z * clampedZoom
                    );
                    
                    camera.lookAt(lookAtPoint.x, lookAtPoint.y, lookAtPoint.z);
                }
            }, { passive: false });

            renderer.domElement.addEventListener('touchend', (e) => {
                e.preventDefault();
                
                if (e.touches.length === 0) {
                    isDragging = false;
                }
                
                // Handle tap for orb selection
                if (e.changedTouches.length === 1 && !isDragging) {
                    const touch = e.changedTouches[0];
                    const canvas = renderer.domElement;
                    const rect = canvas.getBoundingClientRect();
                    mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;

                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(ideologyPoints);

                    if (intersects.length > 0) {
                        const clickedPoint = intersects[0].object;
                        const clickedIndex = ideologyPoints.indexOf(clickedPoint);
                        
                        if (clickedIndex !== -1) {
                            currentFocusIndex = clickedIndex;
                            focusOnPoint();
                        }
                    } else if (userPoint) {
                        const userIntersects = raycaster.intersectObject(userPoint);
                        if (userIntersects.length > 0) {
                            currentFocusIndex = -1;
                            focusOnPoint();
                        }
                    }
                }
            }, { passive: false });

            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                renderer.domElement.style.cursor = 'grabbing';
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;

                    const lookAtPoint = getCurrentLookAt();

                    // Calculate camera position relative to look-at point
                    const offset = new THREE.Vector3(
                        camera.position.x - lookAtPoint.x,
                        camera.position.y - lookAtPoint.y,
                        camera.position.z - lookAtPoint.z
                    );

                    // Rotate around Y axis
                    offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), deltaX * 0.01);
                    
                    // Rotate around X axis
                    const axis = new THREE.Vector3(1, 0, 0);
                    offset.applyAxisAngle(axis, deltaY * 0.01);

                    // Update camera position
                    camera.position.set(
                        lookAtPoint.x + offset.x,
                        lookAtPoint.y + offset.y,
                        lookAtPoint.z + offset.z
                    );
                    
                    camera.lookAt(lookAtPoint.x, lookAtPoint.y, lookAtPoint.z);
                }

                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
                renderer.domElement.style.cursor = 'grab';
            });

            // Zoom with scroll
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomSpeed = 0.1;
                const delta = e.deltaY > 0 ? 1 : -1;
                
                const lookAtPoint = getCurrentLookAt();
                
                // Calculate direction from look-at point to camera
                const direction = new THREE.Vector3(
                    camera.position.x - lookAtPoint.x,
                    camera.position.y - lookAtPoint.y,
                    camera.position.z - lookAtPoint.z
                );
                
                // Scale the distance
                direction.multiplyScalar(1 + delta * zoomSpeed);
                
                // Update camera position
                camera.position.set(
                    lookAtPoint.x + direction.x,
                    lookAtPoint.y + direction.y,
                    lookAtPoint.z + direction.z
                );
                
                camera.lookAt(lookAtPoint.x, lookAtPoint.y, lookAtPoint.z);
            });

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                
                // Rotate user point if it should rotate
                if (userPoint && userPoint.userData.shouldRotate) {
                    userPoint.rotation.y += 0.01;
                }

                // Rotate any ideology points that should rotate
                ideologyPoints.forEach(point => {
                    if (point.userData.shouldRotate) {
                        point.rotation.y += 0.01;
                    }
                });
                
                renderer.render(scene, camera);
            }
            animate();

            // Handle window resize
            window.addEventListener('resize', () => {
                const width = container.clientWidth;
                const height = container.clientHeight;
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            });
        }

        // Color mapping functions for flag generation
        function interpolateColor(color1, color2, factor) {
            // Factor from 0 to 1
            const r1 = parseInt(color1.slice(1, 3), 16);
            const g1 = parseInt(color1.slice(3, 5), 16);
            const b1 = parseInt(color1.slice(5, 7), 16);
            
            const r2 = parseInt(color2.slice(1, 3), 16);
            const g2 = parseInt(color2.slice(3, 5), 16);
            const b2 = parseInt(color2.slice(5, 7), 16);
            
            const r = Math.round(r1 + factor * (r2 - r1));
            const g = Math.round(g1 + factor * (g2 - g1));
            const b = Math.round(b1 + factor * (b2 - b1));
            
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        function scoreToColor(score, negativeColor, positiveColor) {
            // Score ranges from -1 to 1
            // Map to 0 to 1 for interpolation
            const factor = (score + 1) / 2;
            return interpolateColor(negativeColor, positiveColor, factor);
        }

        function createTricolorFlag(economicScore, governanceScore, socialScore) {
            // Map each axis to colors
            // Economic: Red (decelerationism) to Blue (accelerationism)
            const economicColor = scoreToColor(economicScore, '#c0392b', '#3498db');
            
            // Governance: Green (decentralized) to Purple (centralized)
            const governanceColor = scoreToColor(governanceScore, '#27ae60', '#8e44ad');
            
            // Social: Orange (individualism) to Teal (collectivism)
            const socialColor = scoreToColor(socialScore, '#e67e22', '#16a085');
            
            // Create SVG flag
            const svg = `
                <svg class="ideology-flag" viewBox="0 0 48 32" xmlns="http://www.w3.org/2000/svg" title="Top: Growth • Middle: Governance • Bottom: Organization">
                    <rect x="0" y="0" width="48" height="10.67" fill="${economicColor}"/>
                    <rect x="0" y="10.67" width="48" height="10.67" fill="${governanceColor}"/>
                    <rect x="0" y="21.34" width="48" height="10.66" fill="${socialColor}"/>
                </svg>
            `;
            
            return svg;
        }

        function showResults() {
            const { economicScore, governanceScore, socialScore } = calculateResults();
            
            // Map scores to 3D coordinates
            const userCoords = {
                x: governanceScore,  // centralized (positive) to decentralized (negative)
                y: economicScore,    // accelerationism (positive) to decelerationism (negative)
                z: socialScore       // individualism (positive) to collectivism (negative)
            };

            const closestIdeology = findClosestIdeology(userCoords);

            document.getElementById('quiz-section').classList.add('hidden');
            document.getElementById('result-section').classList.remove('hidden');

            // Show score details (in case it was hidden from skip mode)
            document.querySelector('.score-details').style.display = 'grid';

            // Store user's result for later navigation
            userResultDescription = "You are closest to: " + closestIdeology.name + ". " + closestIdeology.description;

            // Create and insert tricolor flag
            const flagSvg = createTricolorFlag(economicScore, governanceScore, socialScore);
            document.getElementById('result-ideology').innerHTML = flagSvg + "Your Position";
            document.getElementById('ideology-description').textContent = userResultDescription;

            // Economic result
            if (economicScore > 0.3) {
                document.getElementById('economic-result').textContent = "Accelerationist - You believe in embracing rapid technological progress and growth.";
            } else if (economicScore < -0.3) {
                document.getElementById('economic-result').textContent = "Decelerationist - You prioritize sustainability, caution, and living within ecological limits.";
            } else {
                document.getElementById('economic-result').textContent = "Moderate - You balance technological acceleration with environmental concerns.";
            }

            // Governance result
            if (governanceScore > 0.3) {
                document.getElementById('governance-result').textContent = "Centralized - You favor concentrated power structures and coordinated decision-making.";
            } else if (governanceScore < -0.3) {
                document.getElementById('governance-result').textContent = "Decentralized - You prefer distributed power and local autonomy.";
            } else {
                document.getElementById('governance-result').textContent = "Moderate - You balance centralized coordination with distributed control.";
            }

            // Social result
            if (socialScore > 0.3) {
                document.getElementById('social-result').textContent = "Individualist - You prioritize personal freedom and autonomy.";
            } else if (socialScore < -0.3) {
                document.getElementById('social-result').textContent = "Collectivist - You emphasize community wellbeing and mutual aid.";
            } else {
                document.getElementById('social-result').textContent = "Moderate - You value both individual rights and collective responsibility.";
            }

            // Initialize 3D visualization
            init3DScene(userCoords);

            // Focus on user's position to add glow effect
            setTimeout(() => {
                focusOnPoint();
            }, 100);
        }

        function restartQuiz() {
            currentQuestion = 0;
            answers = [];
            
            // Clean up Three.js
            if (renderer) {
                renderer.domElement.remove();
                renderer.dispose();
            }
            
            document.getElementById('result-section').classList.add('hidden');
            document.getElementById('intro-section').classList.remove('hidden');
        }

        // Don't initialize on page load - wait for user to click a button
    </script>
</body>
</html>

